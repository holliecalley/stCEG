# Normalize the probabilities for this area
final_probs <- setNames(final_edges$posteriormean / sum(final_edges$posteriormean),
final_edges$label1)
# Store the result for this area
results[[area]] <- final_probs
}
return(results)
}
result <- get_conditional_prob(ceg_data$edges, "Female", "Solved")
View(result)
get_conditional_prob <- function(edges, unique_values, last_group) {
# Always condition on Area1 and Area2
area_values <- shapefileData
area_values <- area_values[[1]]
# Start from root (w0)
current_nodes <- "w0"
# Loop through the user-defined conditions (e.g., Female, Abuse, etc.)
for (condition in unique_values) {
# Filter edges that match the condition and come from the current nodes
filtered_edges <- edges[edges$from %in% current_nodes & edges$label1 == condition, ]
if (nrow(filtered_edges) == 0) {
stop(paste("Condition", condition, "not found in tree!"))
}
# Move to the next nodes
current_nodes <- filtered_edges$to
print(current_nodes)
}
# Initialize an empty list to store results for each area
results <- list()
# Loop through each area and calculate the conditional probabilities
for (area in area_values) {
# Now, filter the edges specifically for the area in question
area_edges <- edges[edges$from %in% current_nodes & edges$label1 == area, ]
if (nrow(area_edges) == 0) {
# Skip to the next iteration if no edges are found for this area
next
}
# Now get the solved/unsolved probabilities for the current area
final_edges <- edges[edges$from %in% area_edges$to & edges$label1 %in% last_group, ]
if (nrow(final_edges) == 0) {
next
}
# Normalize the probabilities for this area
final_probs <- setNames(final_edges$posteriormean / sum(final_edges$posteriormean),
final_edges$label1)
# Store the result for this area
results[[area]] <- final_probs
}
return(results)
}
result <- get_conditional_prob(ceg_data$edges, "Female", "Solved")
ceg_data$edges
ceg_data$edges
ceg_data$nodes
runApp('~/Documents/GitHub/stCEG Github')
calculate_path_products <- function(nodes_df, edges_df, root_node = "w0") {
# Initialize a list to store paths and products
paths_list <- list()
# Find all paths from root node (could use graph traversal here)
traverse_paths <- function(node, path, product) {
# Append node to path
path <- c(path, node)
# Find outgoing edges from current node
next_edges <- edges_df[edges_df$from == node, ]
if (nrow(next_edges) == 0) {
# If no outgoing edges, it's a terminal node, save the path and product
paths_list <<- append(paths_list, list(list(path = path, product = product)))
} else {
# Otherwise, traverse the next nodes
for (i in 1:nrow(next_edges)) {
# Access the posterior_mean from the edge and multiply the product
posterior_mean <- next_edges$posterior_mean[i]
traverse_paths(next_edges$to[i], path, product * posterior_mean)
}
}
}
# Start traversal from the root node
traverse_paths(root_node, path = character(0), product = 1)
# Convert list of paths and products into a data frame
path_df <- do.call(rbind, lapply(paths_list, function(x) data.frame(path = paste(x$path, collapse = " -> "), product = x$product)))
return(path_df)
}
calculate_path_products(ceg_data$nodes, ceg_data$edges)
# Function to calculate posterior mean products for all paths
calculate_path_products <- function(nodes_df, edges_df, root_node = "s0") {
# Initialize a list to store paths and products
paths_list <- list()
# Find all paths from root node (could use graph traversal here)
traverse_paths <- function(node, path, product) {
# Append node to path
path <- c(path, node)
# Find outgoing edges from current node
next_edges <- edges_df[edges_df$from == node, ]
if (nrow(next_edges) == 0) {
# If no outgoing edges, it's a terminal node, save the path and product
# Avoid appending empty paths
if (length(path) > 1) {  # Ensure the path contains more than just the root node
paths_list <<- append(paths_list, list(list(path = path, product = product)))
}
} else {
# Otherwise, traverse the next nodes
for (i in 1:nrow(next_edges)) {
# Access the posterior_mean from the edge and multiply the product
posterior_mean <- next_edges$posterior_mean[i]
traverse_paths(next_edges$to[i], path, product * posterior_mean)
}
}
}
# Start traversal from the root node
traverse_paths(root_node, path = character(0), product = 1)
# Check if paths_list is empty and handle it
if (length(paths_list) == 0) {
stop("No valid paths were found. Check your graph structure.")
}
# Convert list of paths and products into a data frame
path_df <- do.call(rbind, lapply(paths_list, function(x) data.frame(path = paste(x$path, collapse = " -> "), product = x$product)))
return(path_df)
}
# Example usage with the previous data
nodes_df <- data.frame(
node_id = c("s0", "s1", "s2", "s3"),
name = c("Root", "Node 1", "Node 2", "Node 3")
)
edges_df <- data.frame(
from = c("s0", "s0", "s1", "s1", "s2"),
to = c("s1", "s2", "s3", "s2", "s3"),
posterior_mean = c(0.8, 1.2, 0.5, 1.5, 0.9)
)
# Example usage
path_df <- calculate_path_products(nodes_df, edges_df)
print(path_df)
path_df <- calculate_path_products(ceg_data$nodes, ceg_data$edges)
print(path_df)
path_df <- calculate_path_products(ceg_data$nodes, ceg_data$edges)
calculate_path_products <- function(nodes_df, edges_df, root_node = "w0") {
# Initialize a list to store paths and products
paths_list <- list()
# Find all paths from root node (could use graph traversal here)
traverse_paths <- function(node, path, product) {
# Append node to path
path <- c(path, node)
# Find outgoing edges from current node
next_edges <- edges_df[edges_df$from == node, ]
if (nrow(next_edges) == 0) {
# If no outgoing edges, it's a terminal node, save the path and product
# Avoid appending empty paths
if (length(path) > 1) {  # Ensure the path contains more than just the root node
paths_list <<- append(paths_list, list(list(path = path, product = product)))
}
} else {
# Otherwise, traverse the next nodes
for (i in 1:nrow(next_edges)) {
# Access the posterior_mean from the edge and multiply the product
posterior_mean <- next_edges$posterior_mean[i]
traverse_paths(next_edges$to[i], path, product * posterior_mean)
}
}
}
# Start traversal from the root node
traverse_paths(root_node, path = character(0), product = 1)
# Check if paths_list is empty and handle it
if (length(paths_list) == 0) {
stop("No valid paths were found. Check your graph structure.")
}
# Convert list of paths and products into a data frame
path_df <- do.call(rbind, lapply(paths_list, function(x) data.frame(path = paste(x$path, collapse = " -> "), product = x$product)))
return(path_df)
}
# Example usage with the previous data
nodes_df <- data.frame(
node_id = c("s0", "s1", "s2", "s3"),
name = c("Root", "Node 1", "Node 2", "Node 3")
)
edges_df <- data.frame(
from = c("s0", "s0", "s1", "s1", "s2"),
to = c("s1", "s2", "s3", "s2", "s3"),
posterior_mean = c(0.8, 1.2, 0.5, 1.5, 0.9)
)
# Example usage
path_df <- calculate_path_products(ceg_data$nodes, ceg_data$edges)
path_df <- calculate_path_products(ceg_data$nodes, ceg_data$edges)
calculate_path_products <- function(nodes_df, edges_df, root_node = "w0") {
# Initialize a list to store paths and products
paths_list <- list()
# Find all paths from root node (could use graph traversal here)
traverse_paths <- function(node, path, product) {
# Append node to path
path <- c(path, node)
# Find outgoing edges from current node
next_edges <- edges_df[edges_df$from == node, ]
if (nrow(next_edges) == 0) {
# If no outgoing edges, it's a terminal node, save the path and product
# Avoid appending empty paths
if (length(path) > 1) {  # Ensure the path contains more than just the root node
paths_list <<- append(paths_list, list(list(path = path, product = product)))
}
} else {
# Otherwise, traverse the next nodes
for (i in 1:nrow(next_edges)) {
# Access the posterior_mean from the edge and multiply the product
posteriormean <- next_edges$posteriormean[i]
traverse_paths(next_edges$to[i], path, product * posteriormean)
}
}
}
# Start traversal from the root node
traverse_paths(root_node, path = character(0), product = 1)
# Check if paths_list is empty and handle it
if (length(paths_list) == 0) {
stop("No valid paths were found. Check your graph structure.")
}
# Convert list of paths and products into a data frame
path_df <- do.call(rbind, lapply(paths_list, function(x) data.frame(path = paste(x$path, collapse = " -> "), product = x$product)))
return(path_df)
}
path_df <- calculate_path_products(ceg_data$nodes, ceg_data$edges)
calculate_path_products <- function(nodes_df, edges_df, root_node = "w0") {
# Initialize a list to store paths and products
paths_list <- list()
# Find all paths from root node (could use graph traversal here)
traverse_paths <- function(node, path, product) {
# Append node to path
path <- c(path, node)
# Find outgoing edges from current node
next_edges <- edges_df[edges_df$from == node, ]
if (nrow(next_edges) == 0) {
# If no outgoing edges, it's a terminal node, save the path and product
# Avoid appending empty paths
if (length(path) > 1) {  # Ensure the path contains more than just the root node
paths_list <<- append(paths_list, list(list(path = path, product = product)))
}
} else {
# Otherwise, traverse the next nodes
for (i in 1:nrow(next_edges)) {
# Access the posterior_mean from the edge and multiply the product
posteriormean <- as.numeric(next_edges$posteriormean[i])
traverse_paths(next_edges$to[i], path, product * posteriormean)
}
}
}
# Start traversal from the root node
traverse_paths(root_node, path = character(0), product = 1)
# Check if paths_list is empty and handle it
if (length(paths_list) == 0) {
stop("No valid paths were found. Check your graph structure.")
}
# Convert list of paths and products into a data frame
path_df <- do.call(rbind, lapply(paths_list, function(x) data.frame(path = paste(x$path, collapse = " -> "), product = x$product)))
return(path_df)
}
path_df <- calculate_path_products(ceg_data$nodes, ceg_data$edges)
print(path_df)
# Function to calculate posterior mean products for all paths and return label1 -> label2 from edges_df
calculate_path_products <- function(nodes_df, edges_df, root_node = "w0") {
# Initialize a list to store paths and products
paths_list <- list()
# Find all paths from root node (could use graph traversal here)
traverse_paths <- function(node, path, product) {
# Find outgoing edges from current node
next_edges <- edges_df[edges_df$from == node, ]
if (nrow(next_edges) == 0) {
# If no outgoing edges, it's a terminal node, save the path and product
paths_list <<- append(paths_list, list(list(path = path, product = product)))
} else {
# Otherwise, traverse the next nodes
for (i in 1:nrow(next_edges)) {
# Access the posteriormean from the edge
posteriormean <- next_edges$posteriormean[i]
# Append the label1 (from edges_df) to the path
path <- c(path, next_edges$label1[i])
# Continue traversal with the new node
traverse_paths(next_edges$to[i], path, product * posteriormean)
}
}
}
# Start traversal from the root node
traverse_paths(root_node, path = character(0), product = 1)
# Convert list of paths and products into a data frame
path_df <- do.call(rbind, lapply(paths_list, function(x) data.frame(path = paste(x$path, collapse = " -> "), product = x$product)))
return(path_df)
}
# Example usage with modified edges_df that includes label1 and posteriormean
nodes_df <- data.frame(
node_id = c("w0", "w1", "w2", "w3")
)
edges_df <- data.frame(
from = c("w0", "w0", "w1", "w1", "w2"),
to = c("w1", "w2", "w3", "w2", "w3"),
label1 = c("Label A", "Label B", "Label C", "Label D", "Label E"),  # Label1 is in edges_df
posteriormean = c(0.8, 1.2, 0.5, 1.5, 0.9)  # Posterior mean is posteriormean in edges_df
)
# Example usage
path_df <- calculate_path_products(nodes_df, edges_df)
print(path_df)
path_df <- calculate_path_products(ceg_data$nodes, ceg_data$edges)
calculate_path_products <- function(nodes_df, edges_df, root_node = "w0") {
# Initialize a list to store paths and products
paths_list <- list()
# Find all paths from root node (could use graph traversal here)
traverse_paths <- function(node, path, product) {
# Find outgoing edges from current node
next_edges <- edges_df[edges_df$from == node, ]
if (nrow(next_edges) == 0) {
# If no outgoing edges, it's a terminal node, save the path and product
paths_list <<- append(paths_list, list(list(path = path, product = product)))
} else {
# Otherwise, traverse the next nodes
for (i in 1:nrow(next_edges)) {
# Access the posteriormean from the edge
posteriormean <- as.numeric(next_edges$posteriormean[i])
# Append the label1 (from edges_df) to the path
path <- c(path, next_edges$label1[i])
# Continue traversal with the new node
traverse_paths(next_edges$to[i], path, product * posteriormean)
}
}
}
# Start traversal from the root node
traverse_paths(root_node, path = character(0), product = 1)
# Convert list of paths and products into a data frame
path_df <- do.call(rbind, lapply(paths_list, function(x) data.frame(path = paste(x$path, collapse = " -> "), product = x$product)))
return(path_df)
}
path_df <- calculate_path_products(ceg_data$nodes, ceg_data$edges)
print(path_df)
# Function to calculate posterior mean products for all paths and return label1 -> label2 from edges_df
calculate_path_products <- function(nodes_df, edges_df, root_node = "w0") {
# Initialize a list to store paths and products
paths_list <- list()
# Find all paths from root node (could use graph traversal here)
traverse_paths <- function(node, path, product) {
# Find outgoing edges from current node
next_edges <- edges_df[edges_df$from == node, ]
if (nrow(next_edges) == 0) {
# If no outgoing edges, it's a terminal node, save the path and product
paths_list <<- append(paths_list, list(list(path = path, product = product)))
} else {
# Otherwise, traverse the next nodes
for (i in 1:nrow(next_edges)) {
# Access the posteriormean from the edge
posteriormean <- next_edges$posteriormean[i]
# Append the label1 (from edges_df) to the path
new_path <- c(path, next_edges$label1[i])
# Continue traversal with the new node
traverse_paths(next_edges$to[i], new_path, product * posteriormean)
}
}
}
# Start traversal from the root node
traverse_paths(root_node, path = character(0), product = 1)
# Convert list of paths and products into a data frame
path_df <- do.call(rbind, lapply(paths_list, function(x) data.frame(path = paste(x$path, collapse = " -> "), product = x$product)))
return(path_df)
}
# Example usage with modified edges_df that includes label1 and posteriormean
nodes_df <- data.frame(
node_id = c("w0", "w1", "w2", "w3")
)
edges_df <- data.frame(
from = c("w0", "w0", "w1", "w1", "w2"),
to = c("w1", "w2", "w3", "w2", "w3"),
label1 = c("Label A", "Label B", "Label C", "Label D", "Label E"),  # Label1 is in edges_df
posteriormean = c(0.8, 1.2, 0.5, 1.5, 0.9)  # Posterior mean is posteriormean in edges_df
)
# Example usage
path_df <- calculate_path_products(nodes_df, edges_df)
print(path_df)
path_df <- calculate_path_products(ceg_data$nodes, ceg_data$edges)
calculate_path_products <- function(nodes_df, edges_df, root_node = "w0") {
# Initialize a list to store paths and products
paths_list <- list()
# Find all paths from root node (could use graph traversal here)
traverse_paths <- function(node, path, product) {
# Find outgoing edges from current node
next_edges <- edges_df[edges_df$from == node, ]
if (nrow(next_edges) == 0) {
# If no outgoing edges, it's a terminal node, save the path and product
paths_list <<- append(paths_list, list(list(path = path, product = product)))
} else {
# Otherwise, traverse the next nodes
for (i in 1:nrow(next_edges)) {
# Access the posteriormean from the edge
posteriormean <- as.numeric(next_edges$posteriormean[i])
# Append the label1 (from edges_df) to the path
new_path <- c(path, next_edges$label1[i])
# Continue traversal with the new node
traverse_paths(next_edges$to[i], new_path, product * posteriormean)
}
}
}
# Start traversal from the root node
traverse_paths(root_node, path = character(0), product = 1)
# Convert list of paths and products into a data frame
path_df <- do.call(rbind, lapply(paths_list, function(x) data.frame(path = paste(x$path, collapse = " -> "), product = x$product)))
return(path_df)
}
path_df <- calculate_path_products(nodes_df, edges_df)
print(path_df)
path_df <- calculate_path_products(ceg_data$nodes, ceg_data$edges)
print(path_df)
runApp('~/Documents/GitHub/stCEG Github')
path_df
calculate_conditional_prob <- function(path_df, unique_values, last_group) {
# Step 1: Extract paths that match unique_values
condition_paths <- path_df[grepl(paste(unique_values, collapse = " -> "), path_df$path), ]
# Step 2: Sum the product for the joint probability P(last_group and unique_values)
joint_prob <- sum(condition_paths$product[grepl(last_group, condition_paths$path)])
# Step 3: Sum the product for the marginal probability P(unique_values)
marginal_prob <- sum(condition_paths$product)
# Step 4: Calculate conditional probability P(last_group | unique_values)
conditional_prob <- joint_prob / marginal_prob
return(conditional_prob)
}
unique_values <- c("Female", "Domestic Abuse")  # Set of factors you want to condition on
last_group <- "Solved"  # The last factor (e.g., "Solved" or "Unsolved")
# Calculate the conditional probability
conditional_prob <- calculate_conditional_prob(path_df, unique_values, last_group)
# Print the result
print(paste("P(", last_group, "|", paste(unique_values, collapse = ", "), ") = ", conditional_prob, sep = ""))
unique_values <- c("Female", "Not Domestic Abuse")  # Set of factors you want to condition on
last_group <- "Solved"  # The last factor (e.g., "Solved" or "Unsolved")
# Calculate the conditional probability
conditional_prob <- calculate_conditional_prob(path_df, unique_values, last_group)
# Print the result
print(paste("P(", last_group, "|", paste(unique_values, collapse = ", "), ") = ", conditional_prob, sep = ""))
unique_values <- c("Female", "Not Domestic Abuse")  # Set of factors you want to condition on
last_group <- "Unsolved"  # The last factor (e.g., "Solved" or "Unsolved")
# Calculate the conditional probability
conditional_prob <- calculate_conditional_prob(path_df, unique_values, last_group)
# Print the result
print(paste("P(", last_group, "|", paste(unique_values, collapse = ", "), ") = ", conditional_prob, sep = ""))
unique_values <- c("Female", "Not Domestic Abuse", "South West")  # Set of factors you want to condition on
last_group <- "Unsolved"  # The last factor (e.g., "Solved" or "Unsolved")
# Calculate the conditional probability
conditional_prob <- calculate_conditional_prob(path_df, unique_values, last_group)
# Print the result
print(paste("P(", last_group, "|", paste(unique_values, collapse = ", "), ") = ", conditional_prob, sep = ""))
unique_values <- c("Female", "Not Domestic Abuse", "South East")  # Set of factors you want to condition on
last_group <- "Unsolved"  # The last factor (e.g., "Solved" or "Unsolved")
# Calculate the conditional probability
conditional_prob <- calculate_conditional_prob(path_df, unique_values, last_group)
# Print the result
print(paste("P(", last_group, "|", paste(unique_values, collapse = ", "), ") = ", conditional_prob, sep = ""))
runApp('~/Documents/GitHub/stCEG Github')
calculate_conditional_prob <- function(path_df, unique_values, last_group) {
# Step 1: Extract paths that match unique_values
condition_paths <- path_df[grepl(paste(unique_values, collapse = " -> "), path_df$path), ]
# Step 2: Sum the product for the joint probability P(last_group and unique_values)
joint_prob <- sum(condition_paths$product[grepl(last_group, condition_paths$path)])
# Step 3: Sum the product for the marginal probability P(unique_values)
marginal_prob <- sum(condition_paths$product)
# Step 4: Calculate conditional probability P(last_group | unique_values)
conditional_prob <- joint_prob / marginal_prob
print(paste("P(", last_group, "|", paste(unique_values, collapse = ", "), ") = ", conditional_prob, sep = ""))
}
unique_values <- c("Female", "Not Domestic Abuse", "South East")  # Set of factors you want to condition on
last_group <- "Unsolved"  # The last factor (e.g., "Solved" or "Unsolved")
# Calculate the conditional probability
conditional_prob <- calculate_conditional_prob(path_df, unique_values, last_group)
runApp('~/Documents/GitHub/stCEG Github')
runApp('~/Documents/GitHub/stCEG Github')
# Function to calculate the conditional probability
calculate_conditional_prob <- function(path_df, unique_values, last_group) {
# Step 1: Extract paths that match unique_values
condition_paths <- path_df[grepl(paste(unique_values, collapse = " -> "), path_df$path), ]
# Step 2: Sum the product for the joint probability P(last_group and unique_values)
joint_prob <- sum(condition_paths$product[grepl(last_group, condition_paths$path)])
# Step 3: Sum the product for the marginal probability P(unique_values)
marginal_prob <- sum(condition_paths$product)
# Step 4: Calculate conditional probability P(last_group | unique_values)
conditional_prob <- joint_prob / marginal_prob
print(paste("P(", last_group, "|", paste(unique_values, collapse = ", "), ") = ", conditional_prob, sep = ""))
}
unique_values <- c("Female", "Not Domestic Abuse", "South East")  # Set of factors you want to condition on
last_group <- "Unsolved"  # The last factor (e.g., "Solved" or "Unsolved")
# Calculate the conditional probability
conditional_prob <- calculate_conditional_prob(path_df, unique_values, last_group)
unique_values <- c("Female", "South East")  # Set of factors you want to condition on
last_group <- "Unsolved"  # The last factor (e.g., "Solved" or "Unsolved")
# Calculate the conditional probability
conditional_prob <- calculate_conditional_prob(path_df, unique_values, last_group)
calculate_conditional_prob <- function(path_df, unique_values, last_group) {
# Step 1: Sort unique_values to make the order irrelevant
sorted_values <- sort(unique_values)
# Step 2: Create a regular expression that matches any path containing all unique values in any order
condition_paths <- path_df[sapply(path_df$path, function(path) {
all(sapply(sorted_values, function(val) grepl(val, path)))
}), ]
# Step 3: Sum the product for the joint probability P(last_group and unique_values)
joint_prob <- sum(condition_paths$product[grepl(last_group, condition_paths$path)])
# Step 4: Sum the product for the marginal probability P(unique_values)
marginal_prob <- sum(condition_paths$product)
# Step 5: Calculate conditional probability P(last_group | unique_values)
conditional_prob <- joint_prob / marginal_prob
print(paste("P(", last_group, "|", paste(unique_values, collapse = ", "), ") = ", conditional_prob, sep = ""))
}
# Example Usage
unique_values <- c("Female", "South East")  # Set of factors you want to condition on
last_group <- "Unsolved"  # The last factor (e.g., "Solved" or "Unsolved")
# Calculate the conditional probability
conditional_prob <- calculate_conditional_prob(path_df, unique_values, last_group)
# Example Usage
unique_values <- c("South East" , "Female")  # Set of factors you want to condition on
last_group <- "Unsolved"  # The last factor (e.g., "Solved" or "Unsolved")
# Calculate the conditional probability
conditional_prob <- calculate_conditional_prob(path_df, unique_values, last_group)
runApp('~/Documents/GitHub/stCEG Github')
runApp('~/Documents/GitHub/stCEG Github')
runApp('~/Documents/GitHub/stCEG Github')
runApp('~/Documents/GitHub/stCEG Github')
runApp('~/Documents/GitHub/stCEG Github')
runApp('~/Documents/GitHub/stCEG Github')
