#print(updated_edges)
updated_edges <- updated_edges %>%
select(-color) %>%
left_join(contracted_nodes %>% select(id, color), by = c("from" = "id")) %>%  # Drop the existing 'colour' column from edges
rename(colour_from = color)
# Check the column names of updated_edges to ensure 'colour' is the correct name
#print(colnames(updated_edges))
#print(updated_edges)
# Merge and summarize edges
merged_edges <- updated_edges %>%
group_by(from, to, label1, colour_from) %>%
summarise(
sumlabel2 = sum(label2),
sumlabel3 = sum(as.numeric(label3)),
total = (sumlabel2 + sumlabel3),
label_individuals = paste(first(label1), "\n", (sumlabel2 + sumlabel3)),
font.size = first(font.size),
colour_from = first(colour_from),
.groups = 'drop'
)
#print(merged_edges)
merged_edges <- merged_edges %>%
group_by(colour_from) %>%
mutate(stage_total_posterior = sum(total, na.rm = TRUE)) %>%
ungroup()
merged_edges <- merged_edges %>%
group_by(colour_from, label1) %>%
mutate(posterior_total = sum(total, na.rm = TRUE)) %>%
ungroup()
merged_edges <- merged_edges %>%
group_by(colour_from) %>%
mutate(stage_total_prior = sum(sumlabel3, na.rm = TRUE)) %>%
ungroup()
merged_edges <- merged_edges %>%
group_by(colour_from, label1) %>%
mutate(prior_total = sum(sumlabel3, na.rm = TRUE)) %>%
ungroup()
merged_edges$prior_mean <- round(merged_edges$prior_total/merged_edges$stage_total_prior,3)
merged_edges$posterior_mean <- round(merged_edges$posterior_total/merged_edges$stage_total_posterior,3)
merged_edges$label_posterior = paste(merged_edges$label1, "\n", merged_edges$posterior_mean)
merged_edges$label_prior_mean = paste(merged_edges$label1, "\n", merged_edges$prior_mean)
merged_edges$label_prior = paste(merged_edges$label1, "\n", merged_edges$prior_total)
merged_edges$color <- "#000000"
curvature_values <- merged_edges %>%
group_by(from, to) %>%
mutate(
curvature = seq(-0.3, 0.3, length.out = n()) # Ensure curvature is evenly spaced
) %>%
ungroup()
merged_edges$smooth <- pmap(curvature_values, function(from, to, curvature, ...) {
list(enabled = TRUE, type = "curvedCW", roundness = curvature)
})
merged_edges <- merged_edges %>%
left_join(contracted_nodes %>% select(label, level), by = c("from" = "label"))
#assign("ceg_data", list(nodes = contracted_nodes, edges = merged_edges), envir = .GlobalEnv)
# Return the contracted nodes and edges
# print(contracted_nodes)
#print(merged_edges)
if (label == "posterior") {
merged_edges$label <- merged_edges$label_individuals  # Assign "names" (label1)
} else if (label == "posterior_mean") {
merged_edges$label <-  merged_edges$label_posterior  # Assign "priors" (label_prior_frac)
} else if (label == "none") {
merged_edges$label <-  merged_edges$label1  # Assign "priors" (label_prior_frac)
} else if (label == "prior_mean") {
merged_edges$label <-  merged_edges$label_prior_mean # Assign "priors" (label_prior_frac)
} else if (label == "prior") {
merged_edges$label <-  merged_edges$label_prior # Assign "priors" (label_prior_frac)
}
aggregated_df <- merged_edges %>%
group_by(colour_from, level, label1) %>%
summarise(
data = sum(sumlabel2, na.rm = TRUE),
prior = sum(sumlabel3, na.rm = TRUE),
posterior = sum(total, na.rm = TRUE),
.groups = "drop"
) %>%
arrange(level, label1)
aggregated_df <- aggregated_df %>%
group_by(colour_from, level) %>%
summarise(
data = paste(data, collapse = ","),
prior = paste(prior, collapse = ","),
posterior = paste(posterior, collapse = ","),
prior_mean = paste(round(as.numeric(unlist(strsplit(prior, ","))) /
sum(as.numeric(unlist(strsplit(prior, ",")))), 3), collapse = ","),
posterior_mean = paste(round(as.numeric(unlist(strsplit(posterior, ","))) /
sum(as.numeric(unlist(strsplit(posterior, ",")))), 3), collapse = ","),
.groups = "drop"
) %>%
arrange(level)
#print(colnames(aggregated_df))
contracted_nodes <- contracted_nodes %>%
mutate(fixed = list(list(x = TRUE, y = FALSE)))
# Rename the columns in prior_table to match aggregated_df
prior_table <- staged_tree_obj$priortable %>%
rename(colour_from = Colour)
prior_table <- prior_table %>%
rename(level = Level)
# Perform the left join
merged_table <- prior_table %>%
left_join(aggregated_df, by = c("colour_from", "level")) %>%
select(Stage, colour_from, level, data, prior, prior_mean, posterior, posterior_mean) %>%
mutate(
across(c(prior, posterior), ~ map_chr(.x, ~ {
values <- as.numeric(unlist(strsplit(.x, ",")))  # Convert string to numeric vector
if (any(abs(values %% 1 - 0.999) < 1e-6 | abs(values %% 1 - 0.001) < 1e-6)) {
values <- round(values)  # Round if any number ends in .999 or .001
}
paste(values, collapse = ",")  # Rejoin into a string
}))
) %>% rename(
Stage = Stage,
Colour = colour_from,
Level = level,
Data = data,
Prior = prior,
`Prior Mean` = prior_mean,
Posterior = posterior,
`Posterior Mean` = posterior_mean
)
#print("mergedtable")
#print(merged_table)
#  for (col in merged_table$Colour) {
#    styled_text <- make_style(col, bg = TRUE)
#    cat(styled_text(paste(col)), "\n")
#  }
# Ensure 'Colour' is a character vector
merged_table$Colour <- as.character(merged_table$Colour)
ChainEventGraph <- visNetwork(nodes = contracted_nodes, edges = merged_edges) %>%
visHierarchicalLayout(direction = "LR", levelSeparation = level_separation) %>%
visNodes(scaling = list(min = 10, max = 10), font = list(vadjust = -170), fixed = TRUE) %>%
visEdges(arrows = list(to = list(enabled = TRUE, scaleFactor = 5)), smooth = TRUE) %>%
visOptions(
manipulation = list(
enabled = FALSE,
addEdgeCols = FALSE,
addNodeCols = FALSE,
editEdgeCols = FALSE,
editNodeCols = c("color"),
multiselect = TRUE
),
nodesIdSelection = FALSE
) %>%
visInteraction(
dragNodes = TRUE,
multiselect = TRUE,
navigationButtons = TRUE
) %>%
visPhysics(hierarchicalRepulsion = list(nodeDistance = node_distance), stabilization = TRUE) %>%
visEvents(
selectNode = "function(params) { /* Node selection code */ }",
deselectNode = "function(params) { /* Deselect code */ }"
) %>%
visEvents(
selectNode = "function(params) {
var selectedNodeIds = params.nodes; // Array of selected node IDs
// Store the original colours of the edges
var edges = this.body.data.edges.get();
edges.forEach(function(edge) {
if (edge.originalcolour === undefined) {
edge.originalcolour = edge.color; // Store the original edge colour
}
if (edge.originalFontcolour === undefined) {
edge.originalFontcolour = (edge.font && edge.font.color) || '#000000'; // Store the original label colour
}
});
// Reset all edges to their original colours
this.body.data.edges.update(edges.map(function(edge) {
edge.color = edge.originalcolour || '#000000'; // Reset to original or default black
edge.font = { colour: edge.originalFontcolour || '#000000' }; // Reset to original or default black
return edge;
}));
// Highlight edges based on selected nodes
selectedNodeIds.forEach(function(selectedNodeId) {
// Highlight edges going into the selected node (blue)
var incomingEdges = this.body.data.edges.get({
filter: function(edge) {
return edge.to === selectedNodeId;
}
});
incomingEdges.forEach(function(edge) {
edge.color = '#0000FF'; // Set colour to blue
edge.font = { color: '#0000FF' }; // Set label colour to blue
});
this.body.data.edges.update(incomingEdges);
// Highlight edges going out from the selected node (red)
var outgoingEdges = this.body.data.edges.get({
filter: function(edge) {
return edge.from === selectedNodeId;
}
});
outgoingEdges.forEach(function(edge) {
edge.color = '#FF0000'; // Set colour to red
edge.font = { color: '#FF0000' }; // Set label colour to red
});
this.body.data.edges.update(outgoingEdges);
}, this); // Bind `this` to the function to access visNetwork context
// Redraw network to apply changes
this.redraw();
}",
deselectNode = "function(params) {
// When deselecting, reset all edges to their original colours
var edges = this.body.data.edges.get();
this.body.data.edges.update(edges.map(function(edge) {
edge.color = edge.originalcolour || '#000000'; // Reset to original or default black
edge.font = { color: edge.originalFontcolour || '#000000' }; // Reset to original or default black
return edge;
}));
this.redraw();
}"
)%>%
visEvents(stabilizationIterationsDone = "function() { this.physics.options.enabled = false; }")
# Count number of unique stages
num_stages <- length(unique(merged_table$Stage))
# Create the datatable with styling
UpdateTable <- DT::datatable(
merged_table,
escape = FALSE,
class = 'stripe hover row-border compact',  # modern minimal style
options = list(
pageLength = num_stages,
dom = 't<"bottom"i>',  # modern layout: table body, then info and pagination at bottom
columnDefs = list(
list(targets = which(names(merged_table) == "Colour"), visible = FALSE)
),
initComplete = JS(  # modern header styling
"function(settings, json) {",
"$(this.api().table().header()).css({'background-color': '#f9f9f9', 'color': '#333', 'font-family': 'Segoe UI, sans-serif', 'font-size': '14px'});",
"}"
)
)
) %>%
formatStyle(
'Stage',
backgroundColor = styleEqual(merged_table$Stage, merged_table$Colour),
fontFamily = 'Segoe UI, sans-serif',
fontSize = '13px',
color = 'black',
fontWeight = '500',
padding = '6px'
)
# Create the result list (with invisible filtereddf)
result <- invisible(merged_table)
output <- list(ceg = ChainEventGraph, update_table = result)
class(output) <- "chain_event_graph"
# if (view_table) {
#    print(htmltools::browsable(ChainEventGraph))# Display the first object
#    readline(prompt = "Press Enter to see the update table:")  # Wait for user to press Enter
#    print(UpdateTable)  # Display the second object
#  } else {
#    print(htmltools::browsable(ChainEventGraph))
#  }
return(output)
}
fbsfbd <- create_ceg(staged_tree, ree_priors, view_table = TRUE)
fbsfbd
devtools::document()
rm(list = c("create_ceg"))
devtools::document()
devtools::load_all()
fbsfbd <- create_ceg(staged_tree, ree_priors, view_table = TRUE)
fbsfbd
data <- data(homicides)
event_tree <- create_event_tree(data, columns = c(1,2,4,5), "both")
renv::status()
install.packages("tibble")
renv::status()
library(tibble)
renv::status()
data <- data(homicides)
event_tree <- create_event_tree(data, columns = c(1,2,4,5), "both")
devtools::load_all()  # inside your project folder
# OR
library(stCEG)
data <- homicides
event_tree <- create_event_tree(data, columns = c(1,2,4,5), "both")
coloured_tree <- ahc_colouring(event_tree)
tree_priors <- specify_priors(coloured_tree, prior_type = "Uniform")
staged_tree <- staged_tree_prior(coloured_tree, tree_priors)
create_ceg(staged_tree, tree_priors, view_table = TRUE)
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
visNetwork(nodes = ceg$x$nodes, edges = ceg$x$edges)
hi <- visNetwork(nodes = ceg$x$nodes, edges = ceg$x$edges)
hi
hi <- list(c(ceg = visNetwork(nodes = ceg$x$nodes, edges = ceg$x$edges), message = hello))
hi <- list(c(ceg = visNetwork(nodes = ceg$x$nodes, edges = ceg$x$edges), message = "hello"))
hi
hi
devtools::build()
devtools::load_all()
ceg<- create_ceg(staged_tree, tree_priors)
ceg$x
ceg
ChainEventGraph <- visNetwork(nodes = ceg$x$nodes, edges = ceg$x$edges) %>%
visHierarchicalLayout(direction = "LR", levelSeparation = 1200) %>%
visNodes(scaling = list(min = 10, max = 10), font = list(vadjust = -170), fixed = TRUE) %>%
visEdges(arrows = list(to = list(enabled = TRUE, scaleFactor = 5)), smooth = TRUE) %>%
visOptions(
manipulation = list(
enabled = FALSE,
addEdgeCols = FALSE,
addNodeCols = FALSE,
editEdgeCols = FALSE,
editNodeCols = c("color"),
multiselect = TRUE
),
nodesIdSelection = FALSE
) %>%
visInteraction(
dragNodes = TRUE,
multiselect = TRUE,
navigationButtons = TRUE
) %>%
visPhysics(hierarchicalRepulsion = list(nodeDistance = 250), stabilization = TRUE) %>%
visEvents(
selectNode = "function(params) { /* Node selection code */ }",
deselectNode = "function(params) { /* Deselect code */ }"
) %>%
visEvents(
selectNode = "function(params) {
var selectedNodeIds = params.nodes; // Array of selected node IDs
// Store the original colours of the edges
var edges = this.body.data.edges.get();
edges.forEach(function(edge) {
if (edge.originalcolour === undefined) {
edge.originalcolour = edge.color; // Store the original edge colour
}
if (edge.originalFontcolour === undefined) {
edge.originalFontcolour = (edge.font && edge.font.color) || '#000000'; // Store the original label colour
}
});
// Reset all edges to their original colours
this.body.data.edges.update(edges.map(function(edge) {
edge.color = edge.originalcolour || '#000000'; // Reset to original or default black
edge.font = { colour: edge.originalFontcolour || '#000000' }; // Reset to original or default black
return edge;
}));
// Highlight edges based on selected nodes
selectedNodeIds.forEach(function(selectedNodeId) {
// Highlight edges going into the selected node (blue)
var incomingEdges = this.body.data.edges.get({
filter: function(edge) {
return edge.to === selectedNodeId;
}
});
incomingEdges.forEach(function(edge) {
edge.color = '#0000FF'; // Set colour to blue
edge.font = { color: '#0000FF' }; // Set label colour to blue
});
this.body.data.edges.update(incomingEdges);
// Highlight edges going out from the selected node (red)
var outgoingEdges = this.body.data.edges.get({
filter: function(edge) {
return edge.from === selectedNodeId;
}
});
outgoingEdges.forEach(function(edge) {
edge.color = '#FF0000'; // Set colour to red
edge.font = { color: '#FF0000' }; // Set label colour to red
});
this.body.data.edges.update(outgoingEdges);
}, this); // Bind `this` to the function to access visNetwork context
// Redraw network to apply changes
this.redraw();
}",
deselectNode = "function(params) {
// When deselecting, reset all edges to their original colours
var edges = this.body.data.edges.get();
this.body.data.edges.update(edges.map(function(edge) {
edge.color = edge.originalcolour || '#000000'; // Reset to original or default black
edge.font = { color: edge.originalFontcolour || '#000000' }; // Reset to original or default black
return edge;
}));
this.redraw();
}"
)%>%
visEvents(stabilizationIterationsDone = "function() { this.physics.options.enabled = false; }")
ChainEventGraph
devtools::load_all()
ceg<- create_ceg(staged_tree, tree_priors)
ceg
create_ceg(staged_tree, tree_priors)
data <- homicides
event_tree <- create_event_tree(data, columns = c(1,2,4,5), "both")
coloured_tree <- ahc_colouring(event_tree)
tree_priors <- specify_priors(coloured_tree, prior_type = "Uniform")
staged_tree <- staged_tree_prior(coloured_tree, tree_priors)
ceg<- create_ceg(staged_tree, tree_priors)
ceg
devtools::load_all()
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
ceg$table
ceg$network
ceg$network$x
devtools::load_all()
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
devtools::load_all()
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
ceg
ceg$network
ceg$network
devtools::load_all()
devtools::load_all()
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
devtools::load_all()
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
ceg$ceg
devtools::load_all()
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
devtools::load_all()
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
coloured_tree
ceg
coloured_tree
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
devtools::load_all()
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
ceg
homicides_CEG_summary <- summary(ceg)
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
visNetwork(ceg$ceg$x$nodes, ceg$ceg$x$edges)
ChainEventGraph <- visNetwork::visNetwork(nodes = ceg$ceg$x$nodes, edges = ceg$ceg$x$edges) %>%
visHierarchicalLayout(direction = "LR", levelSeparation = 1200) %>%
visNodes(scaling = list(min = 10, max = 10), font = list(vadjust = -170), fixed = TRUE) %>%
visEdges(arrows = list(to = list(enabled = TRUE, scaleFactor = 5)), smooth = TRUE) %>%
visOptions(
manipulation = list(
enabled = FALSE,
addEdgeCols = FALSE,
addNodeCols = FALSE,
editEdgeCols = FALSE,
editNodeCols = c("color"),
multiselect = TRUE
),
nodesIdSelection = FALSE
) %>%
visInteraction(
dragNodes = TRUE,
multiselect = TRUE,
navigationButtons = TRUE
) %>%
visPhysics(hierarchicalRepulsion = list(nodeDistance = 250), stabilization = TRUE) %>%
visEvents(
selectNode = "function(params) { /* Node selection code */ }",
deselectNode = "function(params) { /* Deselect code */ }"
) %>%
visEvents(
selectNode = "function(params) {
var selectedNodeIds = params.nodes; // Array of selected node IDs
// Store the original colours of the edges
var edges = this.body.data.edges.get();
edges.forEach(function(edge) {
if (edge.originalcolour === undefined) {
edge.originalcolour = edge.color; // Store the original edge colour
}
if (edge.originalFontcolour === undefined) {
edge.originalFontcolour = (edge.font && edge.font.color) || '#000000'; // Store the original label colour
}
});
// Reset all edges to their original colours
this.body.data.edges.update(edges.map(function(edge) {
edge.color = edge.originalcolour || '#000000'; // Reset to original or default black
edge.font = { colour: edge.originalFontcolour || '#000000' }; // Reset to original or default black
return edge;
}));
// Highlight edges based on selected nodes
selectedNodeIds.forEach(function(selectedNodeId) {
// Highlight edges going into the selected node (blue)
var incomingEdges = this.body.data.edges.get({
filter: function(edge) {
return edge.to === selectedNodeId;
}
});
incomingEdges.forEach(function(edge) {
edge.color = '#0000FF'; // Set colour to blue
edge.font = { color: '#0000FF' }; // Set label colour to blue
});
this.body.data.edges.update(incomingEdges);
// Highlight edges going out from the selected node (red)
var outgoingEdges = this.body.data.edges.get({
filter: function(edge) {
return edge.from === selectedNodeId;
}
});
outgoingEdges.forEach(function(edge) {
edge.color = '#FF0000'; // Set colour to red
edge.font = { color: '#FF0000' }; // Set label colour to red
});
this.body.data.edges.update(outgoingEdges);
}, this); // Bind `this` to the function to access visNetwork context
// Redraw network to apply changes
this.redraw();
}",
deselectNode = "function(params) {
// When deselecting, reset all edges to their original colours
var edges = this.body.data.edges.get();
this.body.data.edges.update(edges.map(function(edge) {
edge.color = edge.originalcolour || '#000000'; // Reset to original or default black
edge.font = { color: edge.originalFontcolour || '#000000' }; // Reset to original or default black
return edge;
}));
this.redraw();
}"
)%>%
visEvents(stabilizationIterationsDone = "function() { this.physics.options.enabled = false; }")
ChainEventGraph
staged_tree <- staged_tree_prior(coloured_tree, tree_priors)
staged_tree
devtools::load_all()
ceg<- create_ceg(staged_tree, tree_priors, view_table = TRUE)
ceg
